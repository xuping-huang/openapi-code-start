const merge = require('merge-deep')
const debug = require('debug')('api:model')
{{#db_isJsonDB}}
const path = require('path')
const openDB = require('json-file-db')
{{/db_isJsonDB}}
{{#db_isDynamoDB}}
const { DynamoDb, DynamoItem } = require('../lib/dynamo-db')
{{/db_isDynamoDB}}
{{#models}}
{{#model}}
{{#allVars}}
{{#isRefObject}}
const {{refObjectName}} = require('./{{refObjectName}}.model')
{{/isRefObject}}
{{/allVars}}
{{/model}}
{{/models}}
const BaseModel = require('./base.model')

const ID_PREFIX = 'XXX'

const dynamoItem = new DynamoItem()
const dynamoTable = dynamoItem.table('{{name}}')
const dynamoIndexName = dynamoTable.index('indexName')

{{#models}}
{{#model}}
{{#swgdoc}}
/**
 * @swagger
 * definitions:
 *   {{name}}:
 *     required:
         {{#allVars}}
         {{#required}}
 *       - {{name}}
         {{/required}}
         {{/allVars}}
 *     properties:
         {{#allVars}}
 *       {{name}}:
           {{#isRefObject}}
 *         $ref: #/definitions/{{refObjectName}}
 *         description: {{description}}
           {{/isRefObject}}
           {{^isRefObject}}
           {{#isUuid}}
 *         type: string
           {{/isUuid}}
           {{^isUuid}}
 *         type: {{baseType}}
           {{/isUuid}}
           {{#isListContainer}}
 *         items:
           {{#isContainer}}
 *           type: #/definitions/{{complexType}}
           {{/isContainer}}
           {{^isContainer}}
 *           type: {{complexType}}
           {{/isContainer}}
           {{/isListContainer}}
           {{^isListContainer}}
           {{#dataFormat}}
 *         format: {{dataFormat}}
           {{/dataFormat}}
           {{#title}}
 *         title: {{title}}
           {{/title}}
           {{#min}}
 *         min: {{min}}
           {{/min}}
           {{#max}}
 *         max: {{max}}
           {{/max}}
           {{#maxLength}}
 *         maxLength: {{maxLength}}
           {{/maxLength}}
           {{#minLength}}
 *         minLength: {{minLength}}
           {{/minLength}}
           {{#minimum}}
 *         minimum: {{minimum}}
           {{/minimum}}
           {{#maximum}}
 *         maximum: {{maximum}}
           {{/maximum}}
           {{#exclusiveMinimum}}
 *         exclusiveMinimum: {{exclusiveMinimum}}
           {{/exclusiveMinimum}}
           {{#exclusiveMaximum}}
 *         exclusiveMaximum: {{exclusiveMaximum}}
           {{/exclusiveMaximum}}
           {{#isEnum}}
 *         enum:
           {{#_enum}}
 *           - {{.}}
           {{/_enum}}
           {{/isEnum}}
           {{/isListContainer}}
 *         description: {{description}}
           {{/isRefObject}}
         {{/allVars}}
 */
{{/swgdoc}}
{{^swgdoc}}
/**
 * Class representing a {{name}}.
 * @extends BaseModel
 */
{{/swgdoc}}
class {{name}}Model extends BaseModel {
  /**
   * constructor
   * @param {object} values - init values for class instance
   */
  constructor (values) {
    super()
    {{#allVars}}
    {{#isRefObject}}
    this.{{name}} = new {{refObjectName}}()
    {{/isRefObject}}
    {{^isRefObject}}
    this.{{name}} = {{#isListContainer}}[]{{/isListContainer}}{{^isListContainer}}undefined{{/isListContainer}}
    {{/isRefObject}}
    {{/allVars}}

    if (values) {
      this.setValues(values)
    }
  }

  /**
   * set the values.
   * @param {object} values - Can be used to set a webapi response to this newly constructed model
   */
  setValues (values) {
    if (values) {
      {{#allVars}}
      {{#isRefObject}}
      this.{{refObjectName}}.setValues(values.{{refObjectName}})
      {{/isRefObject}}
      {{^isRefObject}}
      {{#isListContainer}}
      this.fillModelArray(this, '{{name}}', values.{{name}}, {{complexType}})
      {{/isListContainer}}
      {{^isListContainer}}
      this.{{name}} = values.{{name}}
      {{/isListContainer}}
      {{/isRefObject}}
      {{/allVars}}
    }
  }

  {{#db_isJsonDB}}
  /**
   * load lookup value of {{name}}
   * @param {object} search - filter {{name}} by - {{#allVars}}{{#needFilter}}{{name}}, {{/needFilter}}{{/allVars}}
   * @return {object} load result
   */
  static async load(search) {
    const filePath = path.join(__dirname, '../../db/{{classFilename}}.json')
    const db = openDB(filePath)
    return new Promise((resolve, reject) => {
      db.get((err, datas) => {
        if (err) return reject(err)
        {{#hasFilterProperty}}
        if (search && search.trim().length > 0) {
          const filter = search.trim().toLowerCase();
          datas = datas.filter((data) => {
            const result = {{#allVars}}{{#needFilter}}{{^isFirstFilter}}|| {{/isFirstFilter}}this.isInclude(data.{{name}}, filter){{/needFilter}}
              {{/allVars}}
            return result
          })
        }
        {{/hasFilterProperty}}
        resolve(datas)
      });
    });
  }
  {{/db_isJsonDB}}
  {{#db_isDynamoDB}}
  /**
   * generate new id
   * @param {string} userId - user id
   * @return {string} the generated id
   */
  newId (userId) {
    return this.genId(ID_PREFIX, userId)
  }

  /**
   * Return item info to save
   * @return {object} the content need be saved
   */
  saveItem () {
    return {
    {{#allVars}}
      {{#isRefObject}}
      {{refObjectName}}: this.{{refObjectName}}{{#hasMore}},{{/hasMore}}
      {{/isRefObject}}
      {{^isRefObject}}
      {{name}}: this.{{name}}{{#hasMore}},{{/hasMore}}
      {{/isRefObject}}
      {{/allVars}}
    }
  }

  /**
   * Return item saving options of dynamoDB
   * @param {object} item - item to save
   * @return {object} a dynamo item content to be saved
   */
  saveOption (item) {
    return dynamoTable.item(item).option()
  }

  /**
   * Save object
   * @param {string} userId - current user id
   * @return {object} saved data
   */
  async save (userId) {
    if (!this.id) {
      this.id = this.newId(userId)
    }

    const item = this.saveItem()
    const options = this.saveOption(item)
    await DynamoDb.put(options).promise()
    return Promise.resolve(item)
  }

  /**
   * Update object with audit log
   * @param {object} auditLog - the audit log for the property changes
   * @return {object} updated data
   */
  async update (auditLog) {
    const item = this.saveItem()
    const options = this.saveOption(item)
    await DynamoDb.put(options).promise()
    return Promise.resolve(item)
  }

  /**
   * Search objects by conditions
   * @param {object} query - the search conditions
   * @return {object} search result
   */
  async search (query) {
    let dynamoOption = dynamoTable.limit(query.perPage)
    if (query.name) dynamoOption = dynamoOption.and().contains('lowerName', query.name.toLowerCase())

    const options = dynamoOption.projectionAll().option()

    const total = await this.getTotal(DynamoDb, dynamoIndexName, 'lowerName', dynamoOption)
    let data = {}
    if (query.page === 1 || query.lastEvaluatedKey) {
      data = await DynamoDb.scan(options).promise()
    } else {
      data = await this.pageSearch(DynamoDb, query.page, query.perPage, total, options)
    }

    const retData = merge(data, { Page: query.page, PerPage: query.perPage, Total: total })
    return Promise.resolve(retData)
  }

  /**
   * Find object by id
   * @param {string} id - the object id
   * @return {object} found object
   */
  async findById (id) {
    const options = dynamoTable.key({ id }).option()
    const data = await DynamoDb.get(options).promise()
    return Promise.resolve(data)
  }
  {{/db_isDynamoDB}}
}
module.exports = {{name}}Model
{{/model}}
{{/models}}
