/**
* Unit test of the {{baseName}}.
*/
const _ = require('lodash');
const merge = require('merge-deep');
const should = require('should');
const moment = require('moment');
const models = require('../../src/model/index');
const testData = require('../lib/testData');
const { failItService } = require('../lib/testHelper');
const {{classname}}Service = require('../../src/service/service.{{classname}}')

const TheModel = models.{{baseName}};
const USER1 = testData.TestUser.RoleUser1;
const USER1_ID = testData.TestUser.RoleUser1.id;

module.exports = describe('{{baseName}} resource', () => {
  let RECORDS = [];
{{#operations}}
{{#operation}}
  xdescribe('{{operationIdSnakeCase}} endpoint', () => {
    const Payload = {
    {{#pathParams}}
      {{paramName}}: 1,
    {{/pathParams}}
      body: {
    {{#bodyParams}}
      {{#isModel}}
        {{#vendorExtensions}}
          {{#x-refModel}}
            {{#vars}}
        {{baseName}}{{#hasMore}},{{/hasMore}}
            {{/vars}}
          {{/x-refModel}}
        {{/vendorExtensions}}
      {{/isModel}}
      {{^isModel}}
        {{baseName}}{{#hasMore}},{{/hasMore}}
      {{/isModel}}
    {{/bodyParams}}
      }
    };
    describe('success request', () => {
      before(async () => {
        RECORDS = await TheModel.findAll();
      });
  {{#vendorExtensions}}
    {{#x-get-method}}
      {{#responses.isListContainer}}
      const assert{{baseName}}SearchBody = async (record, coll, isPagination = false, page = testData.DEFAULT_PAGE, pageSize = testData.DEFAULT_PAGE_SIZE) => {
        if (!isPagination) {
          should.equal(record.total, coll.length);
        } else {
          should.equal(record.total, RECORDS.length);
        }
        should.equal(record.page, page);
        should.equal(record.pageSize, pageSize);
        record.items.forEach((item) => {
          const found = coll.find(col => String(col.id) === String(item.id));
      {{#bodyParams}}
        {{#isModel}}
          {{#vendorExtensions}}
            {{#x-refModel}}
              {{#vars}}
          should.equal(record.{{baseName}}, obj.{{baseName}});
              {{/vars}}
            {{/x-refModel}}
          {{/vendorExtensions}}
        {{/isModel}}
        {{^isModel}}
          should.equal(record.{{baseName}}, obj.{{baseName}});
        {{/isModel}}
      {{/bodyParams}}
          should.equal(item.{{createdBy}}, found.{{createdBy}});
          should.equal(item.{{updatedBy}}, found.{{updatedBy}});
          should.equal(true, moment(item.{{createdAt}}).isAfter(testData.BEFORE_TEST_START));
          should.equal(item.{{createdAt}}, item.{{updatedAt}});
        });
      }
      {{/responses.isListContainer}}
      {{^responses.isListContainer}}
      const assert{{baseName}}GetBody = async (record, obj) => {
        should.equal(record.id, obj.id);
      {{#bodyParams}}
        {{#isModel}}
          {{#vendorExtensions}}
            {{#x-refModel}}
              {{#vars}}
        should.equal(record.{{baseName}}, obj.{{baseName}});
              {{/vars}}
            {{/x-refModel}}
          {{/vendorExtensions}}
        {{/isModel}}
        {{^isModel}}
        should.equal(record.{{baseName}}, obj.{{baseName}});
        {{/isModel}}
      {{/bodyParams}}
        should.equal(record.{{createdBy}}, obj.{{createdBy}});
        should.equal(record.{{updatedBy}}, obj.{{updatedBy}});
        should.equal(true, moment(record.{{createdAt}}).isAfter(testData.BEFORE_TEST_START));
        should.equal(record.{{createdAt}}, moment(obj.{{createdAt}}).toISOString());
        should.equal(record.{{updatedAt}}, moment(obj.{{updatedAt}}).toISOString());
      }
      {{/responses.isListContainer}}
    {{/x-get-method}}
    {{#x-post-method}}
      const assert{{baseName}}CreateBody = async (record, obj, currentUserId) => {
      {{#bodyParams}}
        {{#isModel}}
          {{#vendorExtensions}}
            {{#x-refModel}}
              {{#vars}}
        should.equal(record.{{baseName}}, obj.{{baseName}});
              {{/vars}}
            {{/x-refModel}}
          {{/vendorExtensions}}
        {{/isModel}}
        {{^isModel}}
        should.equal(record.{{baseName}}, obj.{{baseName}});
        {{/isModel}}
      {{/bodyParams}}
        if (currentUserId) {
          should.equal(record.id, obj.id);
          should.equal(record.{{createdBy}}, currentUserId);
          should.equal(record.{{updatedBy}}, currentUserId);
          should.equal(true, moment(record.{{createdAt}}).isAfter(testData.BEFORE_TEST_START));
          should.equal(record.{{createdAt}}, record.{{updatedAt}});
          should.equal(record.{{createdAt}}, moment(obj.{{createdAt}}).toISOString());
          should.equal(record.{{updatedAt}}, moment(obj.{{updatedAt}}).toISOString());
        }
      }
    {{/x-post-method}}
    {{#x-delete-method}}
    {{/x-delete-method}}
    {{#x-put-method}}
      const assert{{baseName}}UpdateBody = async (record, obj, currentUserId) => {
      {{#bodyParams}}
        {{#isModel}}
          {{#vendorExtensions}}
            {{#x-refModel}}
              {{#vars}}
        should.equal(record.{{baseName}}, obj.{{baseName}});
              {{/vars}}
            {{/x-refModel}}
          {{/vendorExtensions}}
        {{/isModel}}
        {{^isModel}}
        should.equal(record.{{baseName}}, obj.{{baseName}});
        {{/isModel}}
      {{/bodyParams}}
        if (currentUserId) {
          should.equal(record.id, obj.id);
          should.equal(record.{{updatedBy}}, currentUserId);
          should.equal(record.{{createdBy}}, obj.{{createdBy}});
          should.equal(record.{{updatedBy}}, obj.{{updatedBy}});
          should.equal(true, moment(record.{{createdAt}}).isAfter(testData.BEFORE_TEST_START));
          should.equal(true, moment(record.{{updatedAt}}).isAfter(moment(record.{{createdAt}})));
          should.equal(record.{{createdAt}}, moment(obj.{{createdAt}}).toISOString());
          should.equal(record.{{updatedAt}}, moment(obj.{{updatedAt}}).toISOString());
        }
      }
    {{/x-put-method}}
    {{#x-patch-method}}
      const assert{{baseName}}PartialUpdateBody = async (record, obj, currentUserId) => {
      should.equal(record.name, obj.name);
      {{#bodyParams}}
        {{#isModel}}
          {{#vendorExtensions}}
            {{#x-refModel}}
              {{#vars}}
        should.equal(record.{{baseName}}, obj.{{baseName}});
              {{/vars}}
            {{/x-refModel}}
          {{/vendorExtensions}}
        {{/isModel}}
        {{^isModel}}
        should.equal(record.{{baseName}}, obj.{{baseName}});
        {{/isModel}}
      {{/bodyParams}}
        if (currentUserId) {
          should.equal(record.id, obj.id);
          should.equal(record.{{updatedBy}}, currentUserId);
          should.equal(record.{{createdBy}}, obj.{{createdBy}});
          should.equal(record.{{updatedBy}}, obj.{{updatedBy}});
          should.equal(true, moment(record.{{createdAt}}).isAfter(testData.BEFORE_TEST_START));
          should.equal(true, moment(record.{{updatedAt}}).isAfter(moment(record.{{createdAt}})));
          should.equal(record.{{createdAt}}, moment(obj.{{createdAt}}).toISOString());
          should.equal(record.{{updatedAt}}, moment(obj.{{updatedAt}}).toISOString());
        }
      }
    {{/x-patch-method}}
  {{/vendorExtensions}}

  {{#vendorExtensions}}
    {{#x-valid-methods}}
      {{^isFailValidate}}
      xit('{{title}}', async () => {
        const params = merge(Payload, { })
        {{#isGetById}}
        const record = await {{classname}}Service.{{operationId}}(params)
        const obj = await TheModel.findOne({ where: { id: 'get id' }, paranoid: false });
        await assert{{baseName}}GetBody(record, obj);
        {{/isGetById}}
        {{#isSearch}}
        const record = await {{classname}}Service.{{operationId}}(params)
        const filters = RECORDS.filter(item => String(item.id) === 'filter condition');
        await assert{{baseName}}SearchBody(record, filters)
        {{/isSearch}}
        {{#isCreate}}
        const oldObj = await TheModel.findOne({ where: { id: 'new id' }, paranoid: false });
        should.equal(true, _.isNull(oldObj));
        const before = moment()
        const record = await {{classname}}Service.{{operationId}}(params, USER1)
        const obj = await TheModel.findOne({ where: { id: 'new id' }, paranoid: false });
        should.equal(true, moment(record.{{createdAt}}).isAfter(before));
        await assert{{baseName}}CreateBody(record, obj, USER1_ID);
        await assert{{baseName}}CreateBody(record, params);
        {{/isCreate}}
        {{#isUpdateById}}
        const oldObj = await TheModel.findOne({ where: { id: 'updated id' }, paranoid: false });
        const record = await {{classname}}Service.{{operationId}}(params, USER1)
        const obj = await TheModel.findOne({ where: { id: 'updated id' }, paranoid: false });
        await assert{{baseName}}UpdateBody(oldObj, obj)
        await assert{{baseName}}UpdateBody(record, obj, USER1_ID);
        await assert{{baseName}}UpdateBody(record, params)
        {{/isUpdateById}}
        {{#isPartialUpdateById}}
        const oldObj = await TheModel.findOne({ where: { id: 'updated id' }, paranoid: false });
        const record = await {{classname}}Service.{{operationId}}(params, USER1)
        const obj = await TheModel.findOne({ where: { id: 'updated id' }, paranoid: false });
        await assert{{baseName}}PartialUpdateBody(oldObj, obj)
        await assert{{baseName}}PartialUpdateBody(record, obj, USER1_ID);
        await assert{{baseName}}PartialUpdateBody(record, params)
        {{/isPartialUpdateById}}
        {{#isDeleteById}}
        const oldObj = await TheModel.findOne({ where: { id: 'deleted id' }, paranoid: false });
        should.exist(oldObj);
        await {{classname}}Service.{{operationId}}(params, USER1)
        const obj = await TheModel.findOne({ where: { id: 'deleted id' }, paranoid: false });
        should.equal(true, _.isNull(obj));
        {{/isDeleteById}}
      });
        {{/isFailValidate}}
      {{/x-valid-methods}}
    {{/vendorExtensions}}
    });

    xdescribe('fail request', () => {
      const params = merge(Payload, { })
    {{#vendorExtensions}}
      {{#x-post-method}}
      {{/x-post-method}}
      {{#x-delete-method}}
      {{/x-delete-method}}
      {{#x-get-method}}
        {{#responses.isListContainer}}
        {{/responses.isListContainer}}
        {{^responses.isListContainer}}
        {{/responses.isListContainer}}
      {{/x-get-method}}
      {{#x-put-method}}
      {{/x-put-method}}
      {{#x-patch-method}}
      {{/x-patch-method}}
    {{/vendorExtensions}}
      const requests = [
      {{#vendorExtensions}}
        {{#x-valid-methods}}
          {{#isFailValidate}}
        {
          title: '{{title}}',
          params,
          status: {{statusCode}},
          message: "Jom.mustPositive('id').message"
        },
          {{/isFailValidate}}
        {{/x-valid-methods}}
      {{/vendorExtensions}}
      ];
      requests.forEach((request) => {
        request.operation = {{classname}}Service.{{operationId}}
        failItService(request);
      });
    });
  })
{{/operation}}

{{/operations}}
})
