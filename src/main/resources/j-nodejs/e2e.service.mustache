/**
* E2E test of the {{baseName}}.
*/
const _ = require('lodash')
const should = require('chai').should()
const moment = require('moment')
const httpStatus = require('http-status')
const jom = require('../lib/jom')
const td = require('../lib/testData')
const th = require('../lib/testHelper')
const tc = require('../lib/testConstants')
const assert = require('../lib/assert')

const ADMIN_USER = td.Token.Admin
const COPILOT_USER = td.Token.Copilot
const USERS = [ADMIN_USER, COPILOT_USER, td.Token.M2M]
const M2M_TOKEN_SUB = td.Token.M2M.sub
let RECORDS = []

module.exports = describe('{{baseName}} resource', () => {
  before(async () => {
    RECORDS = await th.load{{baseName}}Data()
  })
  const formatCreateUrl = () => `${td.BaseUrl}/{{operations.pathPrefix}}s`
  const formatSearchUrl = (body) => {
  const query = th.buildQueryParams(body)
    return body ? `${formatCreateUrl()}${query}` : formatCreateUrl()
  }
  const formatGetUrl = id => `${td.BaseUrl}/{{operations.pathPrefix}}s/${id}`
  const formatUpdateUrl = id => formatGetUrl(id)
  const formatPartiallyUpdateUrl = id => formatGetUrl(id)
  const formatRemoveUrl = id => formatGetUrl(id)

{{#operations}}
  {{#operation}}
    {{#vendorExtensions}}
  xdescribe('{{operationId}} endpoint', () => {
        {{#x-post-method}}
    const before = moment()
    const Payload = {
      body: {
    {{#bodyParams}}
      {{#isModel}}
        {{#vendorExtensions}}
          {{#x-refModel}}
            {{#vars}}
        {{baseName}}: '',
            {{/vars}}
          {{/x-refModel}}
        {{/vendorExtensions}}
      {{/isModel}}
      {{^isModel}}
        {{baseName}}: '',
      {{/isModel}}
    {{/bodyParams}}
      }
    }
        {{/x-post-method}}
        {{#x-put-method}}
    const Payload = {
      id: td.{{baseName}}.ForUpdate.id,
      // TODO: change properties content
      body: {
    {{#bodyParams}}
    {{#isModel}}
      {{#vendorExtensions}}
        {{#x-refModel}}
          {{#vars}}
        {{baseName}}: '',
          {{/vars}}
        {{/x-refModel}}
      {{/vendorExtensions}}
    {{/isModel}}
    {{^isModel}}
        {{baseName}}: '',
    {{/isModel}}
    {{/bodyParams}}
      }
    }
        {{/x-put-method}}
        {{#x-patch-method}}
    const Payload = {
      id: td.{{baseName}}.ForPatch.id,
      // TODO: modify properties content to origin value
      body: {
    {{#bodyParams}}
      {{#isModel}}
        {{#vendorExtensions}}
          {{#x-refModel}}
            {{#vars}}
        {{baseName}}: '',
            {{/vars}}
          {{/x-refModel}}
        {{/vendorExtensions}}
      {{/isModel}}
      {{^isModel}}
        {{baseName}}: '',
      {{/isModel}}
    {{/bodyParams}}
      }
    }
        {{/x-patch-method}}
    describe('success request', () => {
        {{#x-head-method}}
          {{#hasQueryParams}}
      _.each(USERS, user => {
        it(`200 - should success when search all (${user.role})`, async () => {
          const res = await th.headRequest(formatSearchUrl(), user.token)
          should.equal(res.status, httpStatus.OK)
          await th.assertHeadBody(res)
        })
      })
      // TODO: add test values
      const includesQuery = {
      {{#queryParams}}
        {{#isString}}
        {{baseName}}: [],
        {{/isString}}
      {{/queryParams}}
      }
      _.each(includesQuery, (values, key) => {
        _.each(values, value => {
          xit(`200 - ${key}: should success when use '${String(value)}'`, async () => {
            const res = await th.headRequest(formatSearchUrl({ [key]: value }), ADMIN_USER.token)
            should.equal(res.status, httpStatus.OK)
            await th.assertHeadBody(res)
          })
        })
      })
      // TODO: add test values
      const equalQuery = {
      {{#queryParams}}
        {{^isString}}
        {{baseName}}: [],
        {{/isString}}
      {{/queryParams}}
      }
      _.each(equalQuery, (values, key) => {
        _.each(values, value => {
          xit(`200 - ${key}: should success when use '${String(value)}'`, async () => {
            const res = await th.headRequest(formatSearchUrl({ [key]: value }), ADMIN_USER.token)
            should.equal(res.status, httpStatus.OK)
            await th.assertHeadBody(res)
          })
        })
      })
      xit('200 - search: should success when all condition', async () => {
        // TODO: modify body content
        const body = {
        {{#queryParams}}
          {{baseName}}: '',
        {{/queryParams}}
        }
        const res = await th.headRequest(formatSearchUrl(body), ADMIN_USER.token)
        should.equal(res.status, httpStatus.OK)
        await th.assertHeadBody(res)
      })
          {{/hasQueryParams}}
          {{^hasQueryParams}}
      _.each(USERS, user => {
        it(`200 - should success when find by id (${user.role})`, async () => {
          const id = td.{{baseName}}.ForGet.id
          const res = await th.headRequest(formatGetUrl(id), user.token)
          should.equal(res.status, httpStatus.OK)
          await th.assertHeadBody(res)
        })
      })
          {{/hasQueryParams}}
        {{/x-head-method}}
        {{#x-get-method}}
          {{#isListContainer}}
      const assertSearch = async (token) => {
        const res = await th.getRequest(formatSearchUrl(), token)
        should.equal(res.status, httpStatus.OK)
        await assert.{{caseReturnType}}SearchBody(res.body, RECORDS)
      }
      _.each(USERS, user => {
        it(`200 - should success when search all (${user.role})`, async () => {
          await assertSearch(user.token)
        })
      })
      // TODO: add test values
      const includesQuery = {
      {{#queryParams}}
        {{#isString}}
        {{baseName}}: [],
        {{/isString}}
      {{/queryParams}}
      }
      _.each(includesQuery, (values, key) => {
        _.each(values, value => {
          xit(`200 - ${key}: should success when use '${String(value)}'`, async () => {
            const res = await th.getRequest(formatSearchUrl({ [key]: value }), ADMIN_USER.token)
            should.equal(res.status, httpStatus.OK)
            // TODO: if not case insensitive search, you need remove toLowerCase()
            await assert.{{caseReturnType}}SearchBody(res.body,
              RECORDS.filter(item => item[key].toLowerCase().includes(String(value).toLowerCase()))
            )
          })
        })
      })
      // TODO: add test values
      const equalQuery = {
      {{#queryParams}}
        {{^isString}}
        {{baseName}}: [],
        {{/isString}}
      {{/queryParams}}
      }
      _.each(equalQuery, (values, key) => {
        _.each(values, value => {
          xit(`200 - ${key}: should success when use '${String(value)}'`, async () => {
            const data = {}
            data[key] = value
            const res = await th.getRequest(formatSearchUrl(data), ADMIN_USER.token)
            should.equal(res.status, httpStatus.OK)
            await assert.{{caseReturnType}}SearchBody(res.body,
              RECORDS.filter(item => item[key] === value)
            )
          })
        })
      })
      xit('200 - search: should success when all condition', async () => {
        // TODO: modify body content
        const body = {
      {{#queryParams}}
          {{baseName}}: '',
      {{/queryParams}}
        }
        const res = await th.getRequest(formatSearchUrl(body), ADMIN_USER.token)
        should.equal(res.status, httpStatus.OK)
        // TODO: if not case insensitive search, you need remove toLowerCase()
        const items = RECORDS.filter(item => {
          return true
        })
        await assert.{{caseReturnType}}SearchBody(res.body, items)
      })
          {{/isListContainer}}
          {{^isListContainer}}
      _.each(USERS, user => {
        it(`200 - should success when find by id (${user.role})`, async () => {
          const id = td.{{baseName}}.ForGet.id
          const res = await th.getRequest(formatGetUrl(id), user.token)
          should.equal(res.status, httpStatus.OK)
          await assert.{{caseReturnType}}GetBody(res.body, RECORDS.find(item => item.id === id), td.SCRIPT_ID)
        })
      })
          {{/isListContainer}}
        {{/x-get-method}}
        {{#x-post-method}}
      const { body } = Payload
      // TODO: change body assign
      const bodies = {
        [ADMIN_USER.role]: _.assign({}, body, { name: body.name + ` ${ADMIN_USER.role} test` }),
        [COPILOT_USER.role]: _.assign({}, body, { name: body.name + ` ${COPILOT_USER.role} test` }),
        [M2M_TOKEN_SUB]: _.assign({}, body, { name: body.name + ' m2m test' })
      }
      _.each(USERS, user => {
        it(`201 - should success when create (${user.role})`, async () => {
          const oldRes = await th.getRequest(formatSearchUrl(bodies[user.role]), ADMIN_USER.token)
          const res = await th.postRequest(formatCreateUrl(), bodies[user.role], user.token)
          const newRes = await th.getRequest(formatGetUrl(res.body.id), ADMIN_USER.token)
          should.equal(true, _.isEmpty(oldRes.body))
          should.equal(res.status, td.HTTP_STATUS.CREATE_SUCCESS)
          should.equal(true, moment(res.body.createdAt).isAfter(before))
          await assert.{{caseReturnType}}CreateBody(res.body, newRes.body, user.handle || user.sub)
          await assert.{{caseReturnType}}CreateBody(res.body, bodies[user.role])
        })
      })
      xit('200 - should success when whitespace', async () => {
        const newBody = _.assign({}, body, { name: '  ' })
        const oldRes = await th.getRequest(formatSearchUrl(newBody), ADMIN_USER.token)
        const res = await th.postRequest(formatCreateUrl(), newBody, ADMIN_USER.token)
        const newRes = await th.getRequest(formatGetUrl(res.body.id), ADMIN_USER.token)
        should.equal(0, oldRes.body.length)
        should.equal(res.status, td.HTTP_STATUS.CREATE_SUCCESS)
        should.equal(true, moment(res.body.createdAt).isAfter(before))
        await assert.{{caseReturnType}}CreateBody(res.body, newRes.body)
        await assert.{{caseReturnType}}CreateBody(res.body, newBody)
      })
        {{/x-post-method}}
        {{#x-delete-method}}
      const ids = {
        [ADMIN_USER.role]: td.{{baseName}}.ForDelete.id,
        [COPILOT_USER.role]: td.{{baseName}}.ForDelete.id1,
        [M2M_TOKEN_SUB]: td.{{baseName}}.ForDelete.id2
      }
      const assertDelete = async (id, token) => {
        const oldRes = await th.getRequest(formatGetUrl(id), ADMIN_USER.token)
        const res = await th.deleteRequest(formatRemoveUrl(id), token)
        should.exist(oldRes.body)
        should.equal(res.status, td.HTTP_STATUS.DELETE_SUCCESS)
        await th.assertHeadBody(res)
        try {
          await th.getRequest(formatGetUrl(id), ADMIN_USER.token)
        } catch (err) {
          should.equal(_.get(err, tc.PathOfMessage), `{{caseReturnType}}s with id: ${id} does not exist`)
          should.equal(err.status, httpStatus.NOT_FOUND)
        }
      }
      _.each(USERS, user => {
        it(`204 - should success when delete by id (${user.role})`, async () => {
          await assertDelete(ids[user.role], user.token)
        })
      })
        {{/x-delete-method}}
        {{#x-put-method}}
      const { id, body } = Payload
      // TODO: change body assign
      const bodies = {
        [ADMIN_USER.role]: body,
        [COPILOT_USER.role]: _.assign({}, {
      {{#bodyParams}}
      {{#isModel}}
        {{#vendorExtensions}}
          {{#x-refModel}}
            {{#vars}}
          {{baseName}}: body.{{baseName}} + '-user role',
            {{/vars}}
          {{/x-refModel}}
        {{/vendorExtensions}}
      {{/isModel}}
      {{^isModel}}
          {{baseName}}: body.{{baseName}} + '-user role',
      {{/isModel}}
        }),
        [M2M_TOKEN_SUB]: _.assign({}, {
      {{#isModel}}
        {{#vendorExtensions}}
          {{#x-refModel}}
            {{#vars}}
          {{baseName}}: body.{{baseName}} + '-m2m role',
            {{/vars}}
          {{/x-refModel}}
        {{/vendorExtensions}}
      {{/isModel}}
      {{^isModel}}
          {{baseName}}: body.{{baseName}} + '-m2m role',
      {{/isModel}}
      {{/bodyParams}}
        })
      }
      const assertUpdate = async (aBody, token, userId) => {
        const oldRes = await th.getRequest(formatGetUrl(id), ADMIN_USER.token)
        const res = await th.putRequest(formatUpdateUrl(id), aBody, token)
        const newRes = await th.getRequest(formatGetUrl(id), ADMIN_USER.token)
        should.equal(res.status, httpStatus.OK)
        should.not.equal(oldRes.body.name, newRes.body.name)
        should.not.equal(oldRes.body.phase, newRes.body.phase)
        await assert.{{caseReturnType}}UpdateBody(res.body, newRes.body, userId)
        await assert.{{caseReturnType}}UpdateBody(res.body, aBody)
      }
      _.each(USERS, user => {
        it(`200 - should success when update by id (${user.role})`, async () => {
          await assertUpdate(bodies[user.role], user.token, user.handle || user.sub )
        })
      })
      xit('200 - phase: should success when no change', async () => {
        const oldRes = await th.getRequest(formatGetUrl(id), ADMIN_USER.token)
        // TODO: edit properties
        const res = await th.putRequest(formatUpdateUrl(id), _.pick(oldRes.body, ['name', 'more properties']), ADMIN_USER.token)
        const newRes = await th.getRequest(formatGetUrl(id), ADMIN_USER.token)
        should.equal(res.status, httpStatus.OK)
        await assert.{{caseReturnType}}UpdateBody(res.body, newRes.body, ADMIN_USER.handle)
        await assert.{{caseReturnType}}UpdateBody(res.body, oldRes.body)
      })
        {{/x-put-method}}
        {{#x-patch-method}}
      const { id, body } = Payload
      // TODO: change body content
      const bodies = {
        [ADMIN_USER.role]: { name: `${body.name} ${ADMIN_USER.role} update` },
        [COPILOT_USER.role]: { name: `${body.name} ${COPILOT_USER.role} update` },
        [M2M_TOKEN_SUB]: { name: `${body.name} ${M2M_TOKEN_SUB} update` }
      }
      const assertPartiallyUpdate = async (aid, aBody, token, userId) => {
        const oldRes = await th.getRequest(formatGetUrl(aid), ADMIN_USER.token)
        const res = await th.patchRequest(formatPartiallyUpdateUrl(aid), aBody, token)
        const newRes = await th.getRequest(formatGetUrl(aid), ADMIN_USER.token)
        should.equal(res.status, httpStatus.OK)
        _.each(aBody, (value, key) => {
          should.not.equal(oldRes.body[key], newRes.body[key])
          should.equal(newRes.body[key], value)
        })
        await assert.{{caseReturnType}}PartialUpdateBody(res.body, newRes.body, userId)
        await assert.{{caseReturnType}}PartialUpdateBody(res.body, _.assign({}, oldRes.body, aBody))
      }
      _.each(USERS, user => {
        it(`200 - should success when update with '${JSON.stringify(bodies[user.role])}' (${user.role})`, async () => {
          await assertPartiallyUpdate(id, bodies[user.role], user.token, user.handle || user.sub)
        })
      })
      const payloads = [
      {{#bodyParams}}
        {{#isModel}}
          {{#vendorExtensions}}
            {{#x-refModel}}
              {{#vars}}
        body.{{baseName}} + '-partially update',
              {{/vars}}
            {{/x-refModel}}
          {{/vendorExtensions}}
        {{/isModel}}
        {{^isModel}}
        {{baseName}}: body.{{baseName}},
        {{/isModel}}
        {{/bodyParams}}
        body
      ]
      _.each(payloads, payload => {
        xit(`200 - should success when update with '${JSON.stringify(payload)}'`, async () => {
          await assertPartiallyUpdate(id, payload, ADMIN_USER.token, ADMIN_USER.handle)
        })
      })
        {{/x-patch-method}}

        {{#x-valid-methods}}
          {{^isFailValidate}}
      // title: '{{title}}'
          {{/isFailValidate}}
        {{/x-valid-methods}}
    });

    xdescribe('fail request', () => {
        {{#x-post-method}}
      const { body } = Payload
      const URL = formatCreateUrl()
      const requests = []
      requests.push(...th.genStringTests(
        // TODO: modify properties
        ['name'],
        td.STRING_INVALIDS,
        {
          URL,
          token: ADMIN_USER.token,
          body
        }
      ))
      requests.push(...th.genBooleanTests(
        // TODO: modify properties
        ['isActive'],
        td.BOOLEAN_INVALIDS,
        {
          URL,
          token: ADMIN_USER.token,
          body
        }
      ))
      requests.push(...td.authFailRequests(formatCreateUrl(), body))
      _.each(requests, request => {
        request.operation = th.postRequest
        th.failIt(request)
      })
        {{/x-post-method}}
        {{#x-delete-method}}
      const id = td.{{baseName}}.ForGet.id
      const requests = [
      {
        title: '400 - {{caseReturnType}}Id: should fail when not uuid',
        params: [formatRemoveUrl(123), ADMIN_USER.token],
        status: httpStatus.BAD_REQUEST,
        message: jom.mustGuid('{{caseReturnType}}Id').message
      },
      {
        title: '404 - {{caseReturnType}}Id: should fail when not exist',
        params: [formatRemoveUrl(td.NO_EXIST_ID), ADMIN_USER.token],
        status: httpStatus.NOT_FOUND,
        message: td.ErrorMessage.XXX_NOT_EXIST
      }
      ]
      requests.push(...td.authFailRequests(formatRemoveUrl(id)))
      _.each(requests, request => {
        request.operation = th.deleteRequest
        th.failIt(request)
      })
        {{/x-delete-method}}
        {{#x-head-method}}
          {{#hasQueryParams}}
      const URL = formatSearchUrl()
      const requests = []
      requests.push(...th.genStringTests(
        [{{#queryParams}}{{#isString}}'{{baseName}}', {{/isString}}{{/queryParams}}],
        // TODO: change test value
        ['test value'],
        {
          URL,
          token: ADMIN_USER.token,
          isSearch: true
        }
      ))
      requests.push(...th.genBooleanTests(
        [{{#queryParams}}{{#isBoolean}}'{{baseName}}', {{/isBoolean}}{{/queryParams}}],
        td.BOOLEAN_INVALIDS,
        {
          URL,
          token: ADMIN_USER.token,
          isSearch: true
        }
      ))
      requests.push(...td.authFailRequests(formatSearchUrl()))
      _.each(requests, request => {
        request.operation = th.headRequest
        request.message = undefined
        th.failIt(request)
      })
          {{/hasQueryParams}}
          {{^hasQueryParams}}
      const id = td.{{baseName}}.ForGet.id
      const requests = [
        {
          title: '400 - {{caseReturnType}}Id: should fail when invalid id',
          params: [formatGetUrl(123), ADMIN_USER.token],
          status: httpStatus.BAD_REQUEST,
          message: jom.mustGuid('{{caseReturnType}}Id').message
        },
        {
          title: '404 - {{caseReturnType}}Id: should fail when not exist',
          params: [formatGetUrl(td.NO_EXIST_ID), ADMIN_USER.token],
          status: httpStatus.NOT_FOUND,
          message: td.ErrorMessage.XXX_NOT_EXIST
        }
      ]
      requests.push(...td.authFailRequests(formatGetUrl(id)))
      _.each(requests, request => {
        request.operation = th.headRequest
        request.message = undefined
        th.failIt(request)
      })
          {{/hasQueryParams}}
        {{/x-head-method}}
        {{#x-get-method}}
          {{#isListContainer}}
      const URL = formatSearchUrl()
      const requests = []
      requests.push(...th.genStringTests(
        [{{#queryParams}}{{#isString}}'{{baseName}}', {{/isString}}{{/queryParams}}],
        // TODO: change test value
        [''],
        {
          URL,
          token: ADMIN_USER.token,
          isSearch: true
        }
      ))
      requests.push(...th.genBooleanTests(
        [{{#queryParams}}{{#isBoolean}}'{{baseName}}', {{/isBoolean}}{{/queryParams}}],
        td.BOOLEAN_INVALIDS,
        {
          URL,
          token: ADMIN_USER.token,
          isSearch: true
        }
      ))
      requests.push(...td.authFailRequests(formatSearchUrl()))
      _.each(requests, request => {
        request.operation = th.getRequest
        th.failIt(request)
      })
          {{/isListContainer}}
          {{^isListContainer}}
      const id = td.{{baseName}}.ForGet.id
      const requests = [
        {
          title: '400 - {{caseReturnType}}Id: should fail when invalid id',
          params: [formatGetUrl(123), ADMIN_USER.token],
          status: httpStatus.BAD_REQUEST,
          message: jom.mustGuid('{{caseReturnType}}Id').message
        },
        {
          title: '404 - {{caseReturnType}}Id: should fail when not exist',
          params: [formatGetUrl(td.NO_EXIST_ID), ADMIN_USER.token],
          status: httpStatus.NOT_FOUND,
          message: td.ErrorMessage.XXX_NOT_EXIST
        }
      ]
      requests.push(...td.authFailRequests(formatGetUrl(id)))
      _.each(requests, request => {
        request.operation = th.getRequest
        th.failIt(request)
      })
          {{/isListContainer}}
        {{/x-get-method}}
        {{#x-put-method}}
      const { id, body } = Payload
      const URL = formatUpdateUrl(id)
      const requests = []
      // TODO: edit properties
      requests.push(...th.genStringTests(
        ['name', 'more properties'],
        td.STRING_INVALIDS,
        {
          URL,
          token: ADMIN_USER.token,
          body
        }
      ))
      // TODO: edit properties
      requests.push(...th.genBooleanTests(
        ['isActive'],
        td.BOOLEAN_INVALIDS,
        {
          URL,
          token: ADMIN_USER.token,
          body
        }
      ))
      requests.push(...[{
        title: '400 - {{caseReturnType}}Id: should fail when invalid uuid format',
        params: [formatUpdateUrl(123), body, ADMIN_USER.token],
        status: httpStatus.BAD_REQUEST,
        message: jom.mustGuid('{{caseReturnType}}Id').message
      },
      {
        title: '404 - {{caseReturnType}}Id: should fail when id not exist',
        params: [formatUpdateUrl(td.NO_EXIST_ID), body, ADMIN_USER.token],
        status: httpStatus.NOT_FOUND,
        message: td.ErrorMessage.XXX_NOT_EXIST
      }])
      requests.push(...td.authFailRequests(formatUpdateUrl(id), body))
      _.each(requests, request => {
        request.operation = th.putRequest
        th.failIt(request)
      })
        {{/x-put-method}}
        {{#x-patch-method}}
      const { id, body } = Payload
      const URL = formatPartiallyUpdateUrl(id)
      const requests = []
      requests.push(...th.genStringTests(
        // TODO: edit properties
        ['name', 'more properties'],
        td.STRING_INVALIDS.filter(item => !_.isUndefined(item)),
        {
          URL,
          token: ADMIN_USER.token,
          body
        }
      ))
      requests.push(...th.genBooleanTests(
        // TODO: edit properties
        ['isActive'],
        td.BOOLEAN_INVALIDS,
        {
          URL,
          token: ADMIN_USER.token,
          body
        }
      ))
      requests.push(...[{
        title: '400 - {{caseReturnType}}Id: should fail when invalid uuid format',
        params: [formatPartiallyUpdateUrl(123), body, ADMIN_USER.token],
        status: httpStatus.BAD_REQUEST,
        message: jom.mustGuid('{{caseReturnType}}Id').message
      },
      {
        title: '404 - {{caseReturnType}}Id: should fail when id not exist',
        params: [formatPartiallyUpdateUrl(td.NO_EXIST_ID), body, ADMIN_USER.token],
        status: httpStatus.NOT_FOUND,
        message: td.ErrorMessage.XXX_NOT_EXIST
      }])
      requests.push(...td.authFailRequests(formatPartiallyUpdateUrl(id), body))
      _.each(requests, request => {
        request.operation = th.patchRequest
        th.failIt(request)
      })
        {{/x-patch-method}}
        {{#x-valid-methods}}
          {{#isFailValidate}}
      // title: '{{title}}'
          {{/isFailValidate}}
        {{/x-valid-methods}}
    })
  })
    {{/vendorExtensions}}
  {{/operation}}

{{/operations}}
})
